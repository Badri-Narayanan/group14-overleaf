\chapter{Overleaf Compilation & Sync with GitHub}
\label{chap:overleafCI}

\section{System Overview}

\begin{itemize}
    \item \textbf{Overleaf Instance:} DigitalOcean Droplet (IP: 142.93.207.133)
    \item \textbf{Project Path:} \texttt{/root/sharelatex\_data/data/compiles/68f9818f6cbab3ad67b265f7-68f14753eda193f7e7fa0355}
    \item \textbf{Backup Directory:} \texttt{/root/overleaf\_backups}
    \item \textbf{GitHub Repository:} Connected via SSH
    \item \textbf{Automation:} Cron job (every 5 seconds) + GitHub Actions
\end{itemize}

\section{Step 1: SSH into DigitalOcean Droplet}

\begin{minted}{bash}
ssh root@142.93.207.133
\end{minted}

\section{Step 2: Create Backup Directory and Initialize Git}

\begin{minted}{bash}
# Create backup directory
mkdir -p /root/overleaf_backups
cd /root/overleaf_backups

# Initialize git repository
git init
git branch -M main

# Configure git credentials
git config user.name "Badri-Narayanan"
git config user.email "badhrirajen@gmail.com"

# Generate SSH key for GitHub
ssh-keygen -t ed25519 -C "badhrirajen@gmail.com" -f /root/.ssh/id_ed25519 -N ""

# Display public key (add this to GitHub)
cat /root/.ssh/id_ed25519.pub
\end{minted}

\textbf{Add SSH key to GitHub:}
\begin{enumerate}
    \item Copy the public key output
    \item Go to GitHub $\rightarrow$ Settings $\rightarrow$ SSH and GPG keys $\rightarrow$ New SSH key
    \item Paste and save
\end{enumerate}

\begin{minted}{bash}
# Add GitHub remote (replace with your repo URL)
git remote add origin git@github.com:YOUR_USERNAME/YOUR_REPO.git

# Test connection
ssh -T git@github.com
\end{minted}

\section{Step 3: Create Backup Script}

\begin{minted}{bash}
nano /root/backup-overleaf-projects.sh
\end{minted}

\textbf{Script Content:}

\begin{minted}{bash}
#!/bin/bash

# Configuration
SOURCE_DIR="/root/sharelatex_data/data/compiles/68f9818f6cbab3ad67b265f7-68f14753eda193f7e7fa0355"
BACKUP_DIR="/root/overleaf_backups"
LOG_FILE="/var/log/overleaf-backup.log"
GIT_BRANCH="main"
MAX_LOG_SIZE=10485760  # 10MB

# Function to rotate log if too large
rotate_log() {
    if [ -f "$LOG_FILE" ]; then
        LOG_SIZE=$(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null)
        if [ "$LOG_SIZE" -gt "$MAX_LOG_SIZE" ]; then
            mv "$LOG_FILE" "$LOG_FILE.old"
            echo "Log rotated at $(date '+%Y-%m-%d %H:%M:%S')" > "$LOG_FILE"
        fi
    fi
}

# Function to log messages with timestamp
log_message() {
    local TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$TIMESTAMP] $1" >> "$LOG_FILE"
}

# Function to log errors
log_error() {
    local TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$TIMESTAMP] ERROR: $1" >> "$LOG_FILE"
}

# Function to log success
log_success() {
    local TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$TIMESTAMP] SUCCESS: $1" >> "$LOG_FILE"
}

# Rotate log if needed
rotate_log

# Start backup process
log_message "========== Starting backup process =========="

# Check if source directory exists
if [ ! -d "$SOURCE_DIR" ]; then
    log_error "Source directory does not exist: $SOURCE_DIR"
    exit 1
fi

log_message "Source directory exists: $SOURCE_DIR"

# Check if backup directory exists
if [ ! -d "$BACKUP_DIR" ]; then
    log_error "Backup directory does not exist: $BACKUP_DIR"
    exit 1
fi

log_message "Backup directory exists: $BACKUP_DIR"

# Check if backup directory is a git repository
if [ ! -d "$BACKUP_DIR/.git" ]; then
    log_error "Backup directory is not a Git repository: $BACKUP_DIR"
    exit 1
fi

log_message "Git repository detected in backup directory"

# Change to backup directory
cd "$BACKUP_DIR" || {
    log_error "Cannot change to backup directory: $BACKUP_DIR"
    exit 1
}

log_message "Changed to backup directory"

# Check if we're on the correct branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
if [ "$CURRENT_BRANCH" != "$GIT_BRANCH" ]; then
    log_message "Current branch is $CURRENT_BRANCH, switching to $GIT_BRANCH"
    git checkout "$GIT_BRANCH" >> "$LOG_FILE" 2>&1
    if [ $? -ne 0 ]; then
        log_error "Failed to checkout branch $GIT_BRANCH"
        exit 1
    fi
fi

# Stash any local changes to protected files before pulling
log_message "Checking for local changes to protected files"
PROTECTED_FILES=".github .gitignore README.md builds"
HAS_PROTECTED_CHANGES=false

for file in $PROTECTED_FILES; do
    if [ -e "$file" ] && git diff --quiet "$file" 2>/dev/null; then
        :
    elif [ -e "$file" ]; then
        HAS_PROTECTED_CHANGES=true
        break
    fi
done

if [ "$HAS_PROTECTED_CHANGES" = true ]; then
    log_message "Stashing changes to protected files"
    git stash push -m "Auto-stash before pull $(date '+%Y-%m-%d %H:%M:%S')" $PROTECTED_FILES >> "$LOG_FILE" 2>&1
fi

# Pull latest changes from remote
log_message "Pulling latest changes from remote"
git pull origin "$GIT_BRANCH" >> "$LOG_FILE" 2>&1
PULL_EXIT_CODE=$?

if [ $PULL_EXIT_CODE -eq 0 ]; then
    log_success "Successfully pulled from remote"
else
    log_error "Git pull failed with exit code $PULL_EXIT_CODE"
    log_message "Attempting to continue anyway..."
fi

# Pop stashed changes if any
if [ "$HAS_PROTECTED_CHANGES" = true ]; then
    log_message "Restoring stashed changes"
    git stash pop >> "$LOG_FILE" 2>&1
fi

# Ensure .github directory exists
if [ ! -d "$BACKUP_DIR/.github" ]; then
    log_message ".github directory not found, creating it"
    mkdir -p "$BACKUP_DIR/.github/workflows"
fi

# Sync the compiles directory to backup location
log_message "Starting rsync from $SOURCE_DIR to $BACKUP_DIR"

rsync -av --delete \
    --exclude='.git' \
    --exclude='.git/' \
    --exclude='.github' \
    --exclude='.github/' \
    --exclude='.gitignore' \
    --exclude='README.md' \
    --exclude='LICENSE' \
    --exclude='builds' \
    --exclude='builds/' \
    "$SOURCE_DIR/" "$BACKUP_DIR/" >> "$LOG_FILE" 2>&1

RSYNC_EXIT_CODE=$?

if [ $RSYNC_EXIT_CODE -eq 0 ]; then
    log_success "Rsync completed successfully"
else
    log_error "Rsync failed with exit code $RSYNC_EXIT_CODE"
    exit 1
fi

# Check Git status before staging
log_message "Checking for changes in Git repository"
git status --porcelain >> "$LOG_FILE" 2>&1

# Stage all changes
log_message "Staging all changes"
git add -A >> "$LOG_FILE" 2>&1

if [ $? -ne 0 ]; then
    log_error "Failed to stage changes"
    exit 1
fi

# Check if there are any changes to commit
if git diff --cached --quiet; then
    log_message "No changes detected - nothing to commit"
    log_message "========== Backup process completed (no changes) =========="
    exit 0
fi

# Count the changes
ADDED=$(git diff --cached --numstat | wc -l)
log_message "Changes detected: $ADDED file(s) modified/added/deleted"

# Show what changed for debugging
log_message "Files changed:"
git diff --cached --name-status >> "$LOG_FILE" 2>&1

# Create commit message with details
COMMIT_TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
COMMIT_MESSAGE="Auto-backup: $COMMIT_TIMESTAMP

Changes: $ADDED file(s) modified/added/deleted
Source: $SOURCE_DIR"

# Commit the changes
log_message "Committing changes"
git commit -m "$COMMIT_MESSAGE" >> "$LOG_FILE" 2>&1
COMMIT_EXIT_CODE=$?

if [ $COMMIT_EXIT_CODE -ne 0 ]; then
    log_error "Git commit failed with exit code $COMMIT_EXIT_CODE"
    exit 1
fi

log_success "Changes committed successfully"

# Push to remote repository
log_message "Pushing to remote repository (branch: $GIT_BRANCH)"
git push origin "$GIT_BRANCH" >> "$LOG_FILE" 2>&1
PUSH_EXIT_CODE=$?

if [ $PUSH_EXIT_CODE -eq 0 ]; then
    log_success "Changes pushed to remote repository successfully"
    COMMIT_HASH=$(git rev-parse --short HEAD)
    log_message "Commit hash: $COMMIT_HASH"
else
    log_error "Git push failed with exit code $PUSH_EXIT_CODE"
    log_message "Checking if local is behind remote..."
    git fetch origin "$GIT_BRANCH" >> "$LOG_FILE" 2>&1
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse @{u})
    if [ "$LOCAL" != "$REMOTE" ]; then
        log_message "Local is out of sync with remote, will retry on next run"
    fi
    exit 1
fi

log_message "========== Backup process completed successfully =========="
exit 0
\end{minted}

\begin{minted}{bash}
# Make script executable
chmod +x /root/backup-overleaf-projects.sh
\end{minted}

\section{Step 4: Setup Cron Job (Every 5 Seconds)}

\begin{minted}{bash}
crontab -e
\end{minted}

\textbf{Add these lines:}

\begin{minted}{text}
* * * * * /root/backup-overleaf-projects.sh
* * * * * sleep 5; /root/backup-overleaf-projects.sh
* * * * * sleep 10; /root/backup-overleaf-projects.sh
* * * * * sleep 15; /root/backup-overleaf-projects.sh
* * * * * sleep 20; /root/backup-overleaf-projects.sh
* * * * * sleep 25; /root/backup-overleaf-projects.sh
* * * * * sleep 30; /root/backup-overleaf-projects.sh
* * * * * sleep 35; /root/backup-overleaf-projects.sh
* * * * * sleep 40; /root/backup-overleaf-projects.sh
* * * * * sleep 45; /root/backup-overleaf-projects.sh
* * * * * sleep 50; /root/backup-overleaf-projects.sh
* * * * * sleep 55; /root/backup-overleaf-projects.sh
\end{minted}

\textbf{Verify cron is running:}

\begin{minted}{bash}
sudo systemctl status cron
crontab -l
\end{minted}

\section{Step 5: Create GitHub Actions Workflow}

\begin{minted}{bash}
# Create workflow directory
mkdir -p /root/overleaf_backups/.github/workflows

# Create workflow file
nano /root/overleaf_backups/.github/workflows/build.yml
\end{minted}

\textbf{Workflow Content (YAML):}

\begin{minted}{yaml}
name: Build LaTeX PDF
permissions:
  contents: write
on:
  push:
    branches:
      - main
  workflow_dispatch:
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: true
          fetch-depth: 0
      
      - name: Install TeX Live and Pygments
        run: |
          sudo apt-get update
          sudo apt-get install -y texlive-full python3-pygments
      
      - name: Get Git commit hash
        run: echo "GIT_HASH=$(git rev-parse --short HEAD)" >> $GITHUB_ENV
      
      - name: Update version in groupAssignments.tex
        run: |
          sed -i "s/\\\\newcommand{\\\\gitversion}{Unknown}/\\\\newcommand{\\\\gitversion}{${GIT_HASH}}/" groupAssignments.tex
          echo "Updated version to: ${GIT_HASH}"
      
      - name: Compile LaTeX document
        run: |
          pdflatex -shell-escape -interaction=nonstopmode groupAssignments.tex || true
          bibtex groupAssignments || true
          makeindex groupAssignments.idx || true
          pdflatex -shell-escape -interaction=nonstopmode groupAssignments.tex || true
          pdflatex -shell-escape -interaction=nonstopmode groupAssignments.tex || true
      
      - name: Verify PDF was created
        run: |
          if [ -f "groupAssignments.pdf" ]; then
            echo "PDF successfully generated"
            ls -lh groupAssignments.pdf
          else
            echo "ERROR: PDF was not generated!"
            exit 1
          fi
      
      - name: Upload PDF artifact
        uses: actions/upload-artifact@v4
        with:
          name: Compiled-PDF
          path: groupAssignments.pdf
      
      - name: Commit PDF to repo
        if: success()
        env:
          GIT_HASH: ${{ env.GIT_HASH }}
        run: |
          git config user.name "Badri-Narayanan"
          git config user.email "badhrirajen@gmail.com"
          mkdir -p builds
          cp groupAssignments.pdf builds/document_${GIT_HASH}.pdf
          git add builds/document_${GIT_HASH}.pdf
          git commit -m "Auto-build PDF for commit ${GIT_HASH}" || echo "No changes"
          git push origin HEAD:main || echo "Push failed"
\end{minted}

\section{Step 6: Initial Commit and Push}

\begin{minted}{bash}
cd /root/overleaf_backups

# Add .gitignore
cat > .gitignore << 'EOF'
*.log
*.aux
*.out
*.toc
*.synctex.gz
_minted-*
*.idx
*.ilg
*.ind
*.bbl
*.blg
*.fls
*.fdb_latexmk
EOF

# Add all files
git add -A

# Initial commit
git commit -m "Initial commit: Overleaf project setup"

# Push to remote
git push -u origin main
\end{minted}

\section{Step 7: Test the Setup}

\begin{minted}{bash}
# Test backup script manually
/root/backup-overleaf-projects.sh

# Check log
tail -50 /var/log/overleaf-backup.log

# Verify files in backup directory
ls -la /root/overleaf_backups/
\end{minted}

\section{Step 8: Monitoring Commands}

\begin{minted}{bash}
# Watch backup log in real-time
tail -f /var/log/overleaf-backup.log

# Monitor cron execution
grep CRON /var/log/syslog | tail -20

# Check git status
cd /root/overleaf_backups && git status

# View recent commits
cd /root/overleaf_backups && git log --oneline -10

# Check if .github folder is protected
ls -la /root/overleaf_backups/.github/workflows/
\end{minted}

\section{Workflow Process}

\begin{enumerate}
    \item Edit Overleaf document on DigitalOcean (http://devops-group14.app)
    \item Cron job runs every 5 seconds:
    \begin{itemize}
        \item Pulls latest from GitHub
        \item Syncs Overleaf files (excluding .github)
        \item Commits changes
        \item Pushes to GitHub
    \end{itemize}
    \item GitHub Actions triggers:
    \begin{itemize}
        \item Checks out repository
        \item Installs TeX Live
        \item Gets commit hash
        \item Updates version in document
        \item Compiles LaTeX (3 passes)
        \item Creates PDF with version number
        \item Saves to builds/ directory
        \item Commits and pushes PDF back
    \end{itemize}
\end{enumerate}

\section{Verification Checklist}

\begin{itemize}
    \item[$\checkmark$] Cron job running every 5 seconds
    \item[$\checkmark$] Files syncing from Overleaf to GitHub
    \item[$\checkmark$] .github folder protected from deletion
    \item[$\checkmark$] GitHub Actions workflow executing on push
    \item[$\checkmark$] PDF being compiled with commit hash
    \item[$\checkmark$] PDF saved to builds/ directory
    \item[$\checkmark$] All changes committed and pushed
\end{itemize}

\section{Troubleshooting Commands}

\begin{minted}{bash}
# Check cron service
sudo systemctl status cron

# View full backup log
cat /var/log/overleaf-backup.log

# Test rsync without delete
rsync -avn --exclude='.git' --exclude='.github' \
  /root/sharelatex_data/data/compiles/68f9818f6cbab3ad67b265f7-68f14753eda193f7e7fa0355/ \
  /root/overleaf_backups/

# Check SSH connection to GitHub
ssh -T git@github.com

# Force manual sync
cd /root/overleaf_backups && git pull && git push
\end{minted}

\section{Project Structure}

\begin{minted}{text}
/root/overleaf_backups/
|-- .git/
|-- .github/
|   `-- workflows/
|       `-- build.yml
|-- .gitignore
|-- groupAssignments.tex
|-- [other .tex files]
|-- png/
|   `-- [images]
`-- builds/
    `-- document_[hash].pdf
\end{minted}